<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第一篇</title>
    <link href="/2022/04/13/%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <url>/2022/04/13/%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1.绪论"></a>1.绪论</h1><h2 id="1-1-数据结构研究"><a href="#1-1-数据结构研究" class="headerlink" title="1.1 数据结构研究"></a>1.1 数据结构研究</h2><ol><li>主要是解决一些<strong>非数值计算问题</strong>，这些问题无法用数学公式或者方程来描述。</li><li>问题数学模型不是数学方程，而是一些表、树、图这类具有逻辑关系的数据。</li></ol><h2 id="1-2-基本概念和术语"><a href="#1-2-基本概念和术语" class="headerlink" title="1.2 基本概念和术语"></a>1.2 基本概念和术语</h2><h3 id="1-2-1基本概念和术语"><a href="#1-2-1基本概念和术语" class="headerlink" title="1.2.1基本概念和术语"></a>1.2.1基本概念和术语</h3><ol><li>数据：数值型：整数实数，</li></ol><p>​                  非数值型：图像、文字、声音</p><ol start="2"><li><p>数据元素：数据<strong>基本单位</strong>，作为一个整体进行考虑和处理，是集合的个体</p></li><li><p>数据项：构成数据元素的<strong>最小单位</strong></p></li><li><p>数据对象：<strong>性质相同</strong>的<strong>数据元素的集合</strong>，是数据的一个子集</p></li></ol><h3 id="1-2-2-数据结构"><a href="#1-2-2-数据结构" class="headerlink" title="1.2.2 数据结构"></a>1.2.2 数据结构</h3><ol><li><strong>数据元素相互之间的关系</strong>成为结构，数据结构是互相有关系的数据元素的集合</li><li><strong>数据结构包括的三个内容：</strong><ol><li><strong>逻辑结构</strong>：数据元素间的逻辑关系，从具体问题抽象出来的数学模型，与数据的存储无关。<ul><li>线性结构（一对一）：有且仅有一个开始和终端结点，并且所有节点都最多只有一个直接前趋（数据的上一个）和一个直接后继（数据的下一个）<strong>例如：线性表、栈、队列、串</strong></li><li>非线性结构（一对多）：一个结点有多个直接前趋和直接后继  <strong>例如：树、图</strong></li><li>或四种基本逻辑结构：集合、线性（一对一）、树形（一对多）、图状（多对多）</li></ul></li><li><strong>物理结构</strong>：数据元素及其关系在计算机存储器中的结构（存储方式），是数据结构在计算机中的表示<ul><li>顺序存储结构：按照数据元素顺序依次存储，数据元素的逻辑关系由元素存储位置表示 例：c语言中用数组来实现</li><li>链式存储结构：用任意存储单元存储数据元素，数据元素的逻辑关系用指针来表示 例：c语言中用指针来实现</li><li>索引存储结构：在存储结点信息同时，还建立附加的<strong>索引表</strong> </li><li>散列存储：根据结点关键字直接计算结点存储位置</li></ul></li></ol></li></ol><h3 id="1-2-3-数据类型与抽象数据类型"><a href="#1-2-3-数据类型与抽象数据类型" class="headerlink" title="1.2.3 数据类型与抽象数据类型"></a>1.2.3 数据类型与抽象数据类型</h3><ol><li><p>数据类型</p><p>​1. 作用：</p><ul><li><p>约束变量或常量的<strong>取值范围</strong></p></li><li><p>约束变量或常量的<strong>操作</strong></p></li></ul></li></ol><p>​  2. 数据类型定义：一组性质相同的<strong>值的集合</strong>以及定义于这个值集合上的<strong>一组操作</strong>的总称</p><ol start="2"><li><p>抽象数据类型（ADT）：</p><ol><li><p><strong>定义</strong>：指一个数学模型以及定义再次数学模型上的一组操作（不考虑如何在计算机中如何存储）</p></li><li><p><strong>形式定义</strong>：抽象数据类型可用三元组（D,S,P）表示。其中                    </p><p><strong>D</strong> 是数据对象   <strong>S</strong> 是D上的关系集   <strong>P</strong> 是对D的基本操作集</p></li><li><p>定义格式：<img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211122210659836.png" alt="image-20211122210659836" style="zoom:80%;" /></p><p>数据对象、数据关系的定义用伪代码描述</p><p>基本操作的定义格式为：</p><p><strong>基本操作名</strong>（参数表：赋值参数为操作提供输入值                                                                                                    引用参数要以&amp;打头 ） </p><p><strong>初始条件</strong>：&lt;初始条件描述&gt;：操作执行之前数据结构和参数应满足条件，不满足则操作失败，返回出错信息。为空，则省略</p><p><strong>操作结果</strong>：&lt;操作结果描述&gt;：操作正常完成后，数据结构变化状况和返回结果</p></li></ol></li></ol><h2 id="1-3-抽象数据类型的表示与实现"><a href="#1-3-抽象数据类型的表示与实现" class="headerlink" title="1.3 抽象数据类型的表示与实现"></a>1.3 抽象数据类型的表示与实现</h2><h3 id="1-3-1抽象数据类型表示"><a href="#1-3-1抽象数据类型表示" class="headerlink" title="1.3.1抽象数据类型表示"></a>1.3.1抽象数据类型表示</h3><ul><li>见1.2.3</li></ul><h3 id="1-3-2抽象数据类型的实现"><a href="#1-3-2抽象数据类型的实现" class="headerlink" title="1.3.2抽象数据类型的实现"></a>1.3.2抽象数据类型的实现</h3><ul><li><p>利用C语言实现抽象数据类型：</p><ul><li>用已有的数据类型定义描述存储结构</li><li>用函数定义描述它的操作</li></ul></li><li><p>用<strong>类C语言</strong>（介于伪码和C语言之间）作为描述工具</p></li></ul><h2 id="1-4-算法和算法分析"><a href="#1-4-算法和算法分析" class="headerlink" title="1.4 算法和算法分析"></a>1.4 算法和算法分析</h2><h3 id="1-4-1-算法"><a href="#1-4-1-算法" class="headerlink" title="1.4.1 算法"></a>1.4.1 算法</h3><ol><li><p>算法的定义：</p><ul><li>对特定问题<strong>求解方法和步骤</strong>的描述，它是<strong>指令的有限序列</strong>，其中每个指令表示一个或多个操作</li></ul></li><li><p>算法的描述：</p><ul><li>自然语言：英语、中文</li><li>流程图：传统流程图、NS流程图</li><li>伪代码：类语言：类C语言</li><li>程序代码：C语言，JAVA</li></ul></li><li><p>程序与算法：<strong>程序</strong>用某种程序设计语言对算法的具体实现</p></li><li><p>算法的特性：</p><ul><li>有穷性：有穷步骤在有穷时间完成</li><li>确定性：指令有确切含义，没有二义性</li><li>可行性：算法可执行，算法描述的操作通过以实现的基本操作执行有限次实现</li><li>输入：一个算法有<strong>零个</strong>或多个输入</li><li>输出：一个算法有<strong>零个</strong>或多个输出</li></ul></li><li><p>算法设计要求：</p><ul><li>正确性：满足问题要求，能正确解决问题</li><li>可读性：算法应该易于人的理解</li><li>健壮性：输入非法数据时，<strong>恰当的</strong>做出反应或进行相应处理，而不是产生莫名其妙的结果。处理方法应是返回一个表示错误或错误性质的值</li><li>高效性：要求尽量少的时间和尽量低的存储需求</li></ul></li><li><p>对算法的评判处以上条件外，还要考虑<strong>时间效率</strong>和<strong>空间效率</strong></p><p>时间效率和空间效率有时是矛盾的</p><ul><li><p>时间效率：用程序执行所<strong>消耗的时间</strong>来度量（事前分析与事后统计）</p><p>算法运行时间&#x3D;（语句频度×语句执行一次的时间）的累加和</p></li><li><p>时间复杂度：当辅助函数f（n），使n趋近于无穷大是，T(n)&#x2F;f(n)的极限值为一个<strong>不等于零的常数</strong>，则称f(n)是T(n)的同数量级函数。记作T(n)&#x3D;O(f(n)),称O(f(n))为<strong>算法的渐进时间复杂度</strong>(O为数量级的符号)</p><p><strong>随着n的增大，算法执行的时间的增长率和f(n)的整张率相同，称渐进时间复杂度</strong>(对于多项式，只考虑<strong>最高次幂</strong>且不考虑系数)</p><p>有时还随问题的输入数据集不同而不同(考虑时主要考虑<strong>最坏时间复杂度</strong>)</p></li><li><p>空间复杂度：S(n)&#x3D;O(f(n))</p></li></ul></li></ol><h1 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2. 线性表"></a>2. 线性表</h1><h2 id="2-1-线性表的定义和特点"><a href="#2-1-线性表的定义和特点" class="headerlink" title="2.1 线性表的定义和特点"></a>2.1 线性表的定义和特点</h2><ol><li><p>定义：n个具有<strong>相同特性</strong>(必须具有相同特性)的数据元素的一个<strong>有限序列</strong></p><p>起点：起始节点  终点：终端节点</p><p>其中一个数据元素的前一个叫直接前趋，后一个叫直接后继</p><p>n&#x3D;0时，称为<strong>空表</strong></p></li></ol><h2 id="2-2-案例引入"><a href="#2-2-案例引入" class="headerlink" title="2.2 案例引入"></a>2.2 案例引入</h2><ol><li><p>一元多项式的运算：下标相同的项分别相加</p></li><li><p>稀疏多项式：将系数不为零的项，分别把系数和指数存储起来，这样每一个数据元素有两个线性表。</p><p>指数相同：对应系数相加，其和不为零，则在C中增加一个新项</p><p>指数不同：将指数较小的项复制到C中</p></li><li><p>顺序存储结构存在的问题：<strong>存储空间分配不灵活而且运算的空间复杂度高。</strong>所以使用链式储存结构更好，不需要额外空间。</p></li><li><p>许多实际应用问题所涉及的基本操作有很大相似性，不应为每个具体应用单位独编一个程序</p></li><li><p>从具体应用中抽象出共性的<strong>逻辑结构和基本操作</strong>(抽象数据类型)，然后实现其<strong>存储结构和基本操作</strong></p></li></ol><h2 id="2-3-线性表类型定义"><a href="#2-3-线性表类型定义" class="headerlink" title="2.3 线性表类型定义"></a>2.3 线性表类型定义</h2><ol><li>基本操作：<ul><li><strong>InitList</strong>(&amp;L):初始化线性表</li><li><strong>DestroyList</strong>(&amp;L)：销毁线性表(线性表已存在)</li><li><strong>ClearList</strong>（&amp;L）：重置线性表为空表</li><li><strong>ListEmpty</strong>（L）：判断是否为空表</li><li><strong>ListLength</strong>(L):计算线性表中数据元素个数</li><li><strong>GetList</strong>(L,i,&amp;e):用e返回线性表L中第i个数据元素的值</li><li><strong>LocateElem</strong>(L,e,compare() ):compare()是判定函数，返回L中第一个与e满足compare()的数据元素的为序，不存在则返回0</li><li><strong>PriorElem</strong>(L,cur_e,&amp;pre_e):若cur_e不是第一个数据元素，则用pre_e返回它的前趋，否则失败，pre_e无意义</li><li><strong>NextElem</strong>(L,cur_e,&amp;next_e)：若cur_e不是最后一个数据元素，则用pre_e返回它的后继，否则失败，pre_e无意义</li><li><strong>ListInsert</strong>(&amp;L,i,e):在L的第i(1&lt;&#x3D;i&lt;&#x3D;length(L)+1)个位置之前插入新的数据元素e，L长度加一</li><li><strong>ListDelete</strong>(&amp;L,i,&amp;e):删除L的第i(1&lt;&#x3D;i&lt;&#x3D;length(L)+1)个数据元素，L长度减一</li><li>ListTraverse(&amp;L,visited() ):依次对线性表中每个元素调用visited()</li></ul></li></ol><h2 id="2-4-线性表的顺序表示和实现"><a href="#2-4-线性表的顺序表示和实现" class="headerlink" title="2.4 线性表的顺序表示和实现"></a>2.4 线性表的顺序表示和实现</h2><ol><li><p>顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中</p></li><li><p>线性表顺序存储结构益处：因为其占用一篇连续的存储空间，当知道某个元素的存储位置就可以计算其他元素的存储位置</p><p><strong>LOC(a<del>i</del>)&#x3D;LOC(a<del>1</del>)+(n-1)×l</strong></p></li><li><p>如何实现：</p><p>线性表定义模板：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span><span class="hljs-comment">//内存动态分布所需头文件</span></span><br><span class="hljs-comment">//静态分布</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INIT_SIZE 100 <span class="hljs-comment">//线性存储空间的初始分配量</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType elem[LIST_INIT_SIZE]; <span class="hljs-comment">//类型可以根据自己的需要自行修改，即ElemType是自己定义的</span><br>    <span class="hljs-type">int</span> length; <span class="hljs-comment">//当前长度</span><br>&#125;SqList;<span class="hljs-comment">//线性表定义模板</span><br><br><span class="hljs-comment">//动态分布：</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType *date;<br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;<br><span class="hljs-comment">//动态分布的存储空间的分配利用malloc函数来进行分配</span><br>sqlist L;<br>L.date=(ElemType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ElemType)*MaxSize);<br><span class="hljs-comment">//sizeof(ElemType)*MaxSize可以根据定义类型所需字节的不同来获得相应的空间，而不用自己进行计算，MaxSize即每一次开辟的地址空间的数量，(ElemType*)根据定义类型的不同来自动划分空间，加*是为了获得空间的基地址</span><br><span class="hljs-comment">//free(p)函数是释放指针p所指的变量的存储空间用以删除bian</span><br></code></pre></td></tr></table></figure><p>补充：</p><p>C++的参数传递：</p><ul><li>函数调用时传送给形参表的<strong>实参必须与形参一致</strong></li><li>传递方式：（参数为整形、实形、字符型等）</li><li>传地址：参数可以是指针变量、引用类型、数组名</li></ul><ol><li><p>按值传递：把实参的值传送给函数局部工作区的副本中，对副本执行功能修改的是副本的值，实参值不变（类似于将实参复制到副本中）</p></li><li><p>按地址传递：利用指针变量和数组作为参数，其中数组传递的是数组的首地址，改变指针所指地址的值</p><ul><li><p>C++中，传地址方式，用引用类型作参数：如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i=<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> &amp;j=i;<span class="hljs-comment">//相当于j是i的代名词</span><br>i=<span class="hljs-number">7</span>;<span class="hljs-comment">//这个函数中，对i与j的操作是共同作用的，无论对象是谁，都会一起作用</span><br>cout&lt;&lt;<span class="hljs-string">&quot;i=&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;j&quot;</span>&lt;&lt;j;<br></code></pre></td></tr></table></figure><ol><li>传递引用给函数与传递指针的效果一样</li><li>引用类型做形参无副本，直接对实参操作；所以参数传递的数据量较大时，引用比一般变量的空间和时间效率好</li><li>指针参数也能达到使用引用的效果，但需要重复使用“ *指针变量名”容易产生错误且程序阅读性较差</li></ol></li></ul></li></ol><ul><li>函数调用时传送给形参表的实参必须与形参一致</li><li>传递方式：（参数为整形、实形、字符型等）</li><li>传地址：参数可以是指针变量、引用类型、数组名</li></ul><p>C++的动态分配：</p><ul><li><p>int *p&#x3D; new 类型名T (初值列表)</p><p>申请用于存放T类型对象的内存空间，并赋予初值</p><p>成功：T类型的指针</p><p>失败：0</p></li><li><p>delete *p（对标于C中的free）</p><p>功能：释放指针p所指向的内存，p是new 的返回值</p></li></ul></li><li><p>具体操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INFEASIBLE -1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW -2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    ElemType *elem;<br>    <span class="hljs-type">int</span> length;<br>&#125;Sqlist;<br>Sqlist L;<br><span class="hljs-function">Status <span class="hljs-title">Initlist_sq</span><span class="hljs-params">(Sqlist &amp;L)</span></span>&#123;<span class="hljs-comment">//初始化代码</span><br>    L.elem=<span class="hljs-keyword">new</span> ElemType[MAXSIZE];<br>    <span class="hljs-keyword">if</span>(!L.elem) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    L.length=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(Sqlist &amp;L)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L.elem) <span class="hljs-keyword">delete</span> L.elem;<span class="hljs-comment">// 释放存储空间，即销毁线性表</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(Sqlist &amp;l)</span></span>&#123;<br>L.length=<span class="hljs-number">0</span>;<span class="hljs-comment">//  清空线性表内的内容，线性表仍存在</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(Sqlist L)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (L.length);<span class="hljs-comment">//获取线性表长度</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lsEmpty</span><span class="hljs-params">(Sqlist L)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(L.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//检查线性表是否为空</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(Sqlist L,<span class="hljs-type">int</span> i,ElemType &amp;e)</span></span>&#123;<br><span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//判断i的值是否合理，不合理返回error（0）</span><br>    e=L.elem[i<span class="hljs-number">-1</span>];<span class="hljs-comment">//取得第i个值，即顺序表中的L.elem[i-1]</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L,ElemType e)</span></span>&#123;<span class="hljs-comment">//顺序表查找</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;L.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(L.elem[i]==e) <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">Status <span class="hljs-title">ListInsert_sq</span><span class="hljs-params">(Sqlist &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span>&#123;<span class="hljs-comment">//插入一个数据到第i个值前，即插入到[i-1]的位置，将[i-1]以后的所有元素后移一个位置</span><br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;L.length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//判断i值是否越界</span><br>    <span class="hljs-keyword">if</span>(L.length==MAXSIZE) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//判断顺序表是否已经满了</span><br>    <span class="hljs-keyword">for</span>(j=L.length<span class="hljs-number">-1</span>;j&gt;=i<span class="hljs-number">-1</span>;j--)&#123;<br>L.elem[j+<span class="hljs-number">1</span>]=L.elem[j];<br>    &#125;<br>    L.elem[i<span class="hljs-number">-1</span>]=e;<br>    L.length++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function">States <span class="hljs-title">ListDelete_sq</span><span class="hljs-params">(Sqlist &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span>&#123;<span class="hljs-comment">//顺序表的删除</span><br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;L.length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    e=L.elem[i<span class="hljs-number">-1</span>];<span class="hljs-comment">//可要可不要，保留被删除的数据元素</span><br>    <span class="hljs-keyword">for</span>(j=i;j&lt;=L.length;j++)&#123;<span class="hljs-comment">//从第[i]个元素起，依次往前移动</span><br>        L.elem[j<span class="hljs-number">-1</span>]=L.elem[j];<br>    &#125;<br>    L.length--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li></li></ol><h2 id="2-5线性表的链式表示和实现"><a href="#2-5线性表的链式表示和实现" class="headerlink" title="2.5线性表的链式表示和实现"></a>2.5线性表的链式表示和实现</h2><ol><li><p>链式存储结构：</p><ul><li>结点在存储器中位置是任意的，即逻辑相邻在物理上不一定相邻    链表通过指针连在一起</li><li>访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以找第一个结点和最后一个结点所花费的时间不等</li></ul></li><li><p>链式存储术语：</p><ol><li><p>结点：每个节点包括<strong>数据域</strong>和<strong>指针域</strong></p></li><li><p>链表：N个结点<strong>指针链</strong>组成一个链表</p></li><li><p>单链表：结点只有一个指针域</p></li><li><p>双链表：结点有两个指针域的链表（分别指向后继和前趋）</p></li><li><p>循环链表：<strong>首位相接</strong>的链表（在最后一个结点中存储头指针）</p></li><li><p>有指针、头结点、首元结点：<img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211129183500813.png" alt="image-20211129183500813"></p><p>头指针：指向链表中第一个结点的指针</p><p>首元结点：链表中存储第一个数据元素a<del>1</del>的结点</p><p>头结点：实在链表的首元结点之前附设的一个结点（头结点数据域可以为空，也可以存放线性表长度等信息，但是此结点不计入链表长度值）</p><p>设置头结点好处：</p><ul><li>便于首元结点的处理：首元结点的地址保存在头节点指针域中，所以在链表第一个位置上的操作和其他位置一致，无需特殊处理</li><li>便于空表和非空表的统一处理：无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了</li></ul></li><li><p>表示空表：</p><ul><li>无头节点，<strong>头指针为空</strong>时表示为空表</li><li>有头节点，<strong>头节点指针域为空</strong>时表示为空表</li></ul></li></ol></li></ol><h3 id="2-5-1-单链表的定义与表示（带头结点）"><a href="#2-5-1-单链表的定义与表示（带头结点）" class="headerlink" title="2.5.1 单链表的定义与表示（带头结点）"></a>2.5.1 单链表的定义与表示（带头结点）</h3><ol><li><p>单链表是由表头唯一确定，因此单链表可以用头指针名字来命名</p></li><li><p>单链表存储结构：</p><p>定义一个结构体包括数据域和指针域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elemtype;   <span class="hljs-comment">//定义elemtype的数据类型</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">lnode</span>&#123;  <span class="hljs-comment">//</span><br>    elemtype date;     <span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">lnode</span> *next;<span class="hljs-comment">//指针域</span><br>&#125;lnode,*linklist  h     <span class="hljs-comment">//linklist为指向结构体lnode的指针类型</span><br>linklist l;<span class="hljs-comment">// 定义结点指针：lnode *p 或 linklist p;</span><br>例：<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">char</span> num[<span class="hljs-number">8</span>];<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">8</span>];<br>    <span class="hljs-type">int</span> score;<br>&#125;elemtype;<span class="hljs-comment">//先定义一个新的结构体类型</span><br><br>typedf <span class="hljs-keyword">struct</span> <span class="hljs-title class_">lnode</span>&#123;<br>    elemtype date;<span class="hljs-comment">//再用这个结构体类型来定义一个新链表</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">lnode</span> *next;<br>&#125;lnode,*linklist;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-5-2-单链表基本操作的实现"><a href="#2-5-2-单链表基本操作的实现" class="headerlink" title="2.5.2 单链表基本操作的实现"></a>2.5.2 单链表基本操作的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> elemtype;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">lnode</span>&#123;<br>    elemtype date; <span class="hljs-comment">//  elemtype 可以是自己定义的结构体或者其他类型</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">lnode</span> *next;<br>&#125;lnode,*linklist;<br><br><span class="hljs-function">status <span class="hljs-title">initlist_l</span><span class="hljs-params">(linklist &amp;l)</span></span>&#123;<span class="hljs-comment">//初始化单链表</span><br>    l=<span class="hljs-keyword">new</span> lnode;<br>    l-&gt;next=<span class="hljs-number">0</span>;<span class="hljs-comment">//指针置空</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">listempty</span><span class="hljs-params">(linklist l)</span></span>&#123;<span class="hljs-comment">//判断链表是否为空</span><br>    <span class="hljs-keyword">if</span>(l-&gt;next)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function">status <span class="hljs-title">destroylist_l</span><span class="hljs-params">(linklist &amp;l)</span></span>&#123;<span class="hljs-comment">//销毁单链表</span><br>    lnode *p;<br>    <span class="hljs-keyword">while</span>(l)&#123;<br>        p=l;<br>        l=l-&gt;next;<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;  <br>&#125;<br><span class="hljs-function">status <span class="hljs-title">clearlist</span><span class="hljs-params">(linklist &amp;l)</span></span>&#123;<span class="hljs-comment">//清空链表</span><br>    lnode* p;<br>    lnode* q;<br>    p=l-&gt;next;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        q=p-&gt;next;<span class="hljs-comment">//使p的下一项存储在q中</span><br>        <span class="hljs-keyword">delete</span> p;<br>        p=q;<span class="hljs-comment">//使p指向下一项</span><br>    &#125;<br>    l-&gt;next=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function">status <span class="hljs-title">listlength_l</span><span class="hljs-params">(linklist l)</span></span>&#123;<span class="hljs-comment">//链表长度</span><br>    linklist p;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    p=l-&gt;next;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>       i++;<br>       p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-function">status <span class="hljs-title">getelem_l</span><span class="hljs-params">(linklist l,<span class="hljs-type">int</span> i,elemtype &amp;e)</span></span>&#123;<span class="hljs-comment">//取单链表中第i个元素</span><br>    lnode *p=l-&gt;next;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i)&#123;<br>        p=p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p || j&gt;i) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    e=p-&gt;date;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function">lnode *<span class="hljs-title">locateelem_l</span><span class="hljs-params">(linklist l,elemtype e)</span></span>&#123;<span class="hljs-comment">//按值查找 返回地址 </span><br>    lnode* p=l-&gt;next;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;date != e)&#123;<br>        p=p-&gt;next;<br>        <span class="hljs-comment">//i++;          返回位置序号   </span><br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>    <span class="hljs-comment">//if(p) return i;  返回位置序号 </span><br>    <span class="hljs-comment">//else return 0;   返回位置序号 </span><br>&#125;<br><span class="hljs-function">status <span class="hljs-title">listinsert_l</span><span class="hljs-params">(linklist &amp;l,<span class="hljs-type">int</span> i,elemtype e)</span></span>&#123;<span class="hljs-comment">//在第i个元素前插入数据元素e</span><br>    lnode* p=l;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;=i<span class="hljs-number">-1</span>)&#123;p=p-&gt;next;j++;&#125;<span class="hljs-comment">//找到第i-1个结点</span><br>    <span class="hljs-keyword">if</span>(!p || j&gt;j<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// i大于表长+1 或 小于1 无法插入</span><br>    lnode s=<span class="hljs-keyword">new</span> lnode;<br>    s-&gt;date=e; <span class="hljs-comment">// 新建结点s存储e</span><br>    s-&gt;next=p-&gt;next;<span class="hljs-comment">//使第i个结点的地址存储到s中</span><br>    p-&gt;next=s;<span class="hljs-comment">//使第i-1个结点的指针指向s</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function">status <span class="hljs-title">listdelete_l</span><span class="hljs-params">(linklist &amp;l,<span class="hljs-type">int</span> i,elemtype &amp;e)</span></span>&#123;<span class="hljs-comment">//删除第i个元素</span><br>    lnode* p=l;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p-&gt;next &amp;&amp; j&lt;i<span class="hljs-number">-1</span>)&#123;p=p-&gt;next;j++;&#125;<br>    <span class="hljs-keyword">if</span>(!(p-&gt;next) || j&gt;i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    lnode *q;<br>    q=p-&gt;next;<span class="hljs-comment">// 存储第i项</span><br>    p-&gt;next=q-&gt;next;<span class="hljs-comment">//使p指向第i+1项</span><br>    e=q-&gt;date;<span class="hljs-comment">//使第i个结点里的值存储在e中</span><br>    <span class="hljs-keyword">delete</span> q;<span class="hljs-comment">//删除q 即第i个结点</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">creatlist_h</span><span class="hljs-params">(linklist &amp;l,<span class="hljs-type">int</span> n)</span></span>&#123;<span class="hljs-comment">//头插法</span><br>    l=<span class="hljs-keyword">new</span> lnode;<br>    lnode* p;<br>    l-&gt;next=<span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;<span class="hljs-number">0</span>;i++)&#123;<br>        p=<span class="hljs-keyword">new</span> lnode;<span class="hljs-comment">//新建结点</span><br>        cin&gt;&gt;p-&gt;date;<span class="hljs-comment">//输入结点数据域的值</span><br>    &#125;<br>    p-&gt;next=l-&gt;next;<span class="hljs-comment">//使p结点插入到头结点后</span><br>    l-&gt;next=p;<span class="hljs-comment">//使p结点插入到头结点后</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">creatlist_r</span><span class="hljs-params">(linklist &amp;l,<span class="hljs-type">int</span> n)</span></span>&#123;<span class="hljs-comment">//尾插法</span><br>    l=<span class="hljs-keyword">new</span> lnode;<br>    lnode *p;<br>    l-&gt;next=<span class="hljs-number">0</span>;<br>    lnode* r=l;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//生成新的结点，并输出元素</span><br>        p=<span class="hljs-keyword">new</span> lnode;<br>        cin&gt;&gt;p-&gt;date;<br>        p-&gt;next=<span class="hljs-number">0</span>;<span class="hljs-comment">//使尾结点指针指向空</span><br>    r-&gt;next=p;<br>    r=p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-3-循环链表"><a href="#2-5-3-循环链表" class="headerlink" title="2.5.3 循环链表"></a>2.5.3 循环链表</h3><p>循环链表：是一种头尾相接的链表（尾结点指向头结点）</p><p>优点：从表中任意节点出发均可找到其他结点</p><p>终止条件：当p-&gt;next指向头节点时，终止</p><p>带尾指针的循环链表的合并<img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211203184522569.png" alt="image-20211203184522569"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">linklist <span class="hljs-title">connect</span><span class="hljs-params">(linklist ta,linklist tb)</span></span>&#123;<span class="hljs-comment">//带尾指针循环链表的合并</span><br>    lnode *p;<br>    p=ta-&gt;next;     <span class="hljs-comment">//用p存ta表的头结点</span><br>    ta-&gt;next=tb-&gt;next-&gt;next; <span class="hljs-comment">// tb的表头连结ta的表尾</span><br>    <span class="hljs-keyword">delete</span> tb-&gt;next; <span class="hljs-comment">// 释放tb表的头结点</span><br>    tb-&gt;next=p; <span class="hljs-comment">//修改指针</span><br>    <span class="hljs-keyword">return</span> tb;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可设置<strong>双向循环链表：</strong></p><ul><li><p>让头指针的前趋指针指向链表最后一个结点 </p></li><li><p>让最后一个结点的后继指针指向头结点</p></li><li><p><img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211203185458531.png" alt="image-20211203185458531"></p></li></ul><h3 id="2-5-4-双向链表"><a href="#2-5-4-双向链表" class="headerlink" title="2.5.4 双向链表"></a>2.5.4 双向链表</h3><ol><li><p>双向链表：有两个指针一个前趋指针，一个后继指针</p></li><li><p>在求长度和输出元素时，算法与线性链表相同。但插入和删除时须<strong>同时</strong>修改<strong>两个方向的指针</strong></p></li><li><p>定义算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dulnode</span>&#123;<br>    elemtype date; <span class="hljs-comment">//  elemtype 可以是自己定义的结构体或者其他类型</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dulnode</span> *next;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dulnode</span> *prior;<br>&#125;dulnode,*dulinklist;<br></code></pre></td></tr></table></figure></li><li><p>插入</p><ol><li><img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211205194605061.png" alt="image-20211205194605061"></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">linkinsert_dul</span><span class="hljs-params">(dulinklist &amp;l,elemtype e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!(p=<span class="hljs-built_in">getelemp_dul</span>(l,i))) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//判断数据是否合法</span><br>    linklist s=<span class="hljs-keyword">new</span> dulnode;<br>    s-&gt;date=e;<br>    s-&gt;prior=p-&gt;prior;<br>    p-&gt;prior-&gt;next=s;<br>    s-&gt;next=p;<br>    p-&gt;prior=s;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-comment">// 双向链表的插入</span><br></code></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">status <span class="hljs-title">listdelete_dul</span><span class="hljs-params">(dulinklist &amp;l,<span class="hljs-type">int</span> i,elemtype e)</span></span>&#123;<br>    dulinklist p;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>(!(p=<span class="hljs-built_in">getelemp_dul</span>(l,i))) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//判断数据是否合法</span><br>    e=p-&gt;date;<br>    p-&gt;prior-&gt;next=p-next;<br>    p-&gt;next-&gt;prior=p-&gt;prior;<br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-6顺序表和链表的比较"><a href="#2-6顺序表和链表的比较" class="headerlink" title="2.6顺序表和链表的比较"></a>2.6顺序表和链表的比较</h2><ul><li>链式存储结构的优点：<ul><li>结点空间可以<strong>动态申请和释放</strong></li><li><strong>插入与删除时不需要移动数据元素</strong></li></ul></li><li>链式存储结构的缺点<ul><li>存储密度小，每个结点的指针域需要额外的存储空间</li><li>是<strong>非随机存取</strong>结构。对任意节点的操作都要从头指针依指针链查找，算法复杂度增加</li></ul></li></ul><p><img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211206120124861.png" alt="image-20211206120124861"></p><h2 id="2-7线性表的应用"><a href="#2-7线性表的应用" class="headerlink" title="2.7线性表的应用"></a>2.7线性表的应用</h2><ol><li><p><strong>线性表的合并</strong>：</p><p><strong>问题描述</strong>：假设利用两个线性表La和Lb分别表示两个集合A和B，现要求一个新的集合A&#x3D;A∪B</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union</span><span class="hljs-params">(linklist &amp;la,linklist &amp;lb)</span></span>&#123;<br>    <span class="hljs-type">int</span> la_len,lb_len;<br>    la_len=<span class="hljs-built_in">listlength</span>(la);<br>    lb_len=<span class="hljs-built_in">listlength</span>(lb);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lb_len;i++)&#123;<br>        <span class="hljs-built_in">getelem</span>(lb,i,e);<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">locateelem</span>(la,e)) <span class="hljs-built_in">listinsert</span>(&amp;la,++la_len)<br>    &#125;<br>&#125;<span class="hljs-comment">//l</span><br></code></pre></td></tr></table></figure></li><li><p>有序表的合并：</p><p>顺序表：</p><p><strong>问题描述</strong>：已知线性表La和Lb中的数据元素按值非递减有序排列，现要求将La和Lb归并为一个新的线性表Lc，且Lc中的数据元素仍按值非递减有序排列</p><p><img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211207203852163.png" alt="image-20211207203852163"></p><p><img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211207204325596.png" alt="image-20211207204325596"></p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergelist_sq</span><span class="hljs-params">(sqlist la,sqlist lb,sqlist &amp;lc)</span></span>&#123;<span class="hljs-comment">//s</span><br>    <span class="hljs-type">int</span>* pa=la.elem;<br>    <span class="hljs-type">int</span>* pb=lb.elem;<br>    lc.length=la.length+lb.length;<br>    lc.elem=<span class="hljs-keyword">new</span> elemtype[lc.length];<br>    <span class="hljs-type">int</span>* pc=lc.elem;<br>    <span class="hljs-type">int</span>* pa_last=la.elem+la.length<span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span>* pb_last=lb.elem+lb.length<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(pa&lt;=pa_last &amp;&amp; pb&lt;=pb_last)&#123;<br>        <span class="hljs-keyword">if</span>(*pa&lt;=*pb) *pc++=*pa++;<br>        <span class="hljs-keyword">else</span> *pc++=*pb++;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(pa&lt;=pa_last) *pc++=*pa++;<br>    <span class="hljs-keyword">while</span>(pb&lt;=pb_last) *pc++=*pa++;<br>&#125;<br></code></pre></td></tr></table></figure><p>链表：前提是合并的两个链表也是有序链表</p><p><img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211207210456690.png" alt="image-20211207210456690"></p><p><img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211207210812526.png" alt="image-20211207210812526"></p><p> 代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mregelist_l</span><span class="hljs-params">(linklist &amp;la,linklist &amp;lb,linklist &amp;lc)</span></span>&#123;<span class="hljs-comment">//两个有序链表的合并</span><br>    lnode* pa=la-&gt;next;<br>    lnode* pb=lb-&gt;next;<br>    lnode* pc;<br>    pc=lc=la;  <span class="hljs-comment">//用la的头结点作为lc的头结点</span><br>    <span class="hljs-keyword">while</span>(pa &amp;&amp; pb)&#123;<br>        <span class="hljs-keyword">if</span>(pa-&gt;date&lt;=pb-&gt;date)&#123;<br>            pc-&gt;next=pa;<br>            pc=pa;<br>            pa=pa-&gt;next;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            pc-&gt;next=pb;<br>            pc=pb;<br>            pb=pb-&gt;next;<br>        &#125;<br>    &#125;<br>    pc-&gt;next=pa?pa:pb;<br>    <span class="hljs-keyword">delete</span> lb;<span class="hljs-comment">// 释放头结点</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h2 id="2-8案例分析与实现"><a href="#2-8案例分析与实现" class="headerlink" title="2.8案例分析与实现"></a>2.8案例分析与实现</h2><ol><li><p>案例一：</p><p>一元多项式的运算：</p><p><img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211207212715775.png" alt="image-20211207212715775"></p><p>下标对应次方。</p></li><li><p>案例二：</p><p>稀疏多项式的运算：每一个数据域存储两个量</p><p>顺序表：</p><p><img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211207213248583.png" alt="image-20211207213248583"></p><p>链式表：两个数据域，一个存储次方，一个存储系数</p><p>定义链表</p><p><img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211207213440734.png" alt="image-20211207213440734"></p><p><img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211207213530533.png" alt="image-20211207213530533"></p><p>计算步骤：</p><p><img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211207213825729.png" alt="image-20211207213825729"></p><p><img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211207214250055.png" alt="image-20211207214250055"></p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <br></code></pre></td></tr></table></figure></li><li><p>图书信息管理管理：</p><p><img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211207214609152.png" alt="image-20211207214609152"></p><p><img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20211207214705792.png" alt="image-20211207214705792"></p></li><li></li></ol><h1 id="3-栈和队列"><a href="#3-栈和队列" class="headerlink" title="3.栈和队列"></a>3.栈和队列</h1><h2 id="3-1-栈和队列的定义与特点"><a href="#3-1-栈和队列的定义与特点" class="headerlink" title="3.1 栈和队列的定义与特点"></a>3.1 栈和队列的定义与特点</h2><p>特点：也是线性表，但与一般线性表不同，具有特定的插入与删除顺序，仅能在表的端点进行插入与删除</p><h3 id="3-1-1-栈的定义和特点"><a href="#3-1-1-栈的定义和特点" class="headerlink" title="3.1.1 栈的定义和特点"></a>3.1.1 栈的定义和特点</h3><p>栈（stack）：删除与插入只能在表尾操作（且后进先出：先删除在插入）（LIFO：last in frist out）</p><p>表尾称为<strong>栈顶（top）</strong>表头成为<strong>栈底（base）</strong></p><p>插入元素到栈顶成为<strong>入栈</strong>（push）删除最后一个元素成为<strong>出栈</strong>（pop）</p><p>存储结构有顺序栈与链栈均有，逻辑结构是一对一</p><h3 id="3-1-2-队列的定义和特点"><a href="#3-1-2-队列的定义和特点" class="headerlink" title="3.1.2 队列的定义和特点"></a>3.1.2 队列的定义和特点</h3><p>队列：表尾插入，表头删除，先进先出（FIFO：Frist in Frist out）<br>队列常见应用方面：类似排队问题 </p><p>存储结构有顺序队与链队，以<strong>循环顺序队列</strong>更为常见</p><h2 id="3-2-案例引入"><a href="#3-2-案例引入" class="headerlink" title="3.2 案例引入"></a>3.2 案例引入</h2><h2 id="3-3-栈的表示和操作的实现"><a href="#3-3-栈的表示和操作的实现" class="headerlink" title="3.3 栈的表示和操作的实现"></a>3.3 栈的表示和操作的实现</h2><h3 id="3-3-2-顺序栈的表示与实现"><a href="#3-3-2-顺序栈的表示与实现" class="headerlink" title="3.3.2 顺序栈的表示与实现"></a>3.3.2 顺序栈的表示与实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW 0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> selemtype;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<span class="hljs-comment">//顺序栈的表示</span><br>    selemtype *base;<br>    selemtype *top;<br>    <span class="hljs-type">int</span> stacksize;<br>&#125;sqstack;<br><br><span class="hljs-function">status <span class="hljs-title">initstack</span><span class="hljs-params">(sqstack &amp;s)</span><span class="hljs-comment">//顺序栈的初始化</span></span><br><span class="hljs-function"></span>&#123;<br>    s.base = <span class="hljs-keyword">new</span> selemtype[MAXSIZE];<span class="hljs-comment">//或s.base= (selemtype*)malloc(MAXSIZE*sizeof(selemtype));</span><br>    <span class="hljs-keyword">if</span>(!s.base) exit;OVERFLOW;<br>    s.top=s.base;<br>    s.stacksize=MAXSIZE;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">stackempty</span><span class="hljs-params">(sqstack s)</span></span>&#123;<span class="hljs-comment">//判断是否为空</span><br>    <span class="hljs-keyword">if</span>(s.top==s.base) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stacklength</span><span class="hljs-params">(sqstack s)</span></span>&#123;<span class="hljs-comment">//长度</span><br>    <span class="hljs-keyword">return</span> s.top-s.base;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">clearstack</span><span class="hljs-params">(sqstack s)</span></span>&#123;<span class="hljs-comment">//清空</span><br>    <span class="hljs-keyword">if</span>(s.base) s.top = s.base;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">destroystack</span><span class="hljs-params">(sqstack &amp;s)</span></span>&#123;<span class="hljs-comment">//销毁</span><br>    <span class="hljs-keyword">if</span>(s.base)&#123;<br>        <span class="hljs-keyword">delete</span> s.base;<br>        s.stacksize=<span class="hljs-number">0</span>;<br>        s.base=s.top=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">push</span><span class="hljs-params">(sqstack &amp;s,selemtype e)</span></span>&#123;<span class="hljs-comment">//顺序栈的入栈</span><br>    <span class="hljs-keyword">if</span>(s.top-s.base == s.stacksize)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    *s.top++=e;<span class="hljs-comment">//等价于：*s.top=e;s.top++;</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">pop</span><span class="hljs-params">(sqstack s,selemtype &amp;e)</span></span>&#123;<span class="hljs-comment">//顺序栈的出栈</span><br>    <span class="hljs-keyword">if</span>(s.top == s.base)&#123;<span class="hljs-comment">//等价于if(stackempty(s))</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    e=*--s.top;<span class="hljs-comment">//等价于--s.top;e=*s.top;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-3-链栈的表示和实现"><a href="#3-3-3-链栈的表示和实现" class="headerlink" title="3.3.3 链栈的表示和实现"></a>3.3.3 链栈的表示和实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stactnode</span>&#123;<br>    selemtype date;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stacknode</span> *next;<br>&#125;stactnode,*linkstact;<br>linkstact s;   <br><br><span class="hljs-function">status <span class="hljs-title">stackempty</span><span class="hljs-params">(linkstack s)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">push</span><span class="hljs-params">(linkstack &amp;s,selemtype e)</span></span>&#123;<span class="hljs-comment">//入栈</span><br>    linkstack* p=<span class="hljs-keyword">new</span> stacknode;<br>    p-&gt;date=e;<br>    p-&gt;next=s;<br>    s=p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function">status <span class="hljs-title">pop</span><span class="hljs-params">(linkstack &amp;s,selemtype e)</span></span>&#123;<span class="hljs-comment">//出栈</span><br>    <span class="hljs-keyword">if</span>（s==<span class="hljs-literal">NULL</span>） <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    linkstack *p;<br>    e=s-&gt;date;<br>    p=s;<br>    s=s-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">gettop</span><span class="hljs-params">(linkstack s)</span></span>&#123;<span class="hljs-comment">//取栈顶元素</span><br>    <span class="hljs-keyword">if</span>(s!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> s-&gt;date;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-栈与递归"><a href="#3-4-栈与递归" class="headerlink" title="3.4 栈与递归"></a>3.4 栈与递归</h2><h2 id="3-5-队列的表示和操作的实现"><a href="#3-5-队列的表示和操作的实现" class="headerlink" title="3.5 队列的表示和操作的实现"></a>3.5 队列的表示和操作的实现</h2><h3 id="3-5-1顺序队列"><a href="#3-5-1顺序队列" class="headerlink" title="3.5.1顺序队列"></a>3.5.1顺序队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    qelemtype *base;<br>    <span class="hljs-type">int</span> front;<span class="hljs-comment">//头指针</span><br>    <span class="hljs-type">int</span> rear;<span class="hljs-comment">//尾指针</span><br>&#125;sqqueue;<br><br><span class="hljs-function">status <span class="hljs-title">initqueue</span><span class="hljs-params">(sqqueue &amp;q)</span></span>&#123;<span class="hljs-comment">//初始化</span><br>    q.base = <span class="hljs-keyword">new</span> qelemtype[MAXSIZE];<span class="hljs-comment">//分配空间</span><br>    <span class="hljs-keyword">if</span>(!q.base) <span class="hljs-built_in">exit</span> (OVERFLOW); <span class="hljs-comment">//判断是否分配成功</span><br>    q.front=q.rear=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queuelength</span><span class="hljs-params">(sqqueue q)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> ((q.rear-q.front+MAXQSIZE)%MAXQSIZE)<span class="hljs-comment">//可能会有相减成负数的情况</span><br>&#125;<br><br>status <span class="hljs-built_in">equeue</span>(sqqueue &amp;q,qelemtype e)&#123;<span class="hljs-comment">//入队</span><br>    <span class="hljs-keyword">if</span>((q.rear+<span class="hljs-number">1</span>)%MAXQSIZE == q.front) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//判断队列是否已经满了</span><br>    q.base[q.rear]=e;<br>    q.rear=(q.rear+<span class="hljs-number">1</span>)%MAXQSIZE;<span class="hljs-comment">//使尾指针后移，若在队尾且队头为空，则移动到队头,目的为了解决假上溢</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">dequeue</span><span class="hljs-params">(sqqueue &amp;q,qelemtyoe &amp;e)</span></span>&#123;<span class="hljs-comment">//出队</span><br>    <span class="hljs-keyword">if</span>(q.front==q.rear) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    e=q.base[q.front];<br>    q.front=(q.front+<span class="hljs-number">1</span>)%MAXQSIZE;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function">selemtype <span class="hljs-title">gethead</span><span class="hljs-params">(sqqueue q)</span></span>&#123;<span class="hljs-comment">//取头元素</span><br>    <span class="hljs-keyword">if</span>(q.front!=q.rear)<br>        <span class="hljs-keyword">return</span> q.base[q.front];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-2-链队列"><a href="#3-5-2-链队列" class="headerlink" title="3.5.2 链队列"></a>3.5.2 链队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">qnode</span>&#123;<br>    qelemtype date;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">qnode</span> *next;<br>&#125;qnode,*queneptr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    queneptr front;<br>    queneptr rear;<br>&#125;linkqueue;<br><br><span class="hljs-function">status <span class="hljs-title">initqueue</span><span class="hljs-params">(linkqueue &amp;q)</span></span>&#123;<span class="hljs-comment">//初始化</span><br>    q.front=q.rear=(queueptr)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(qnode));<br>    <span class="hljs-keyword">if</span>(!q.front)<span class="hljs-built_in">exit</span> (OVERFLOW);<br>    q.front-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">destroyqueue</span><span class="hljs-params">(linkqueue &amp;q)</span></span>&#123;<span class="hljs-comment">//销毁</span><br>    queneptr* p;<br>    <span class="hljs-keyword">while</span>(q.front)&#123;<br>        p=q.front-&gt;next;<br>        <span class="hljs-built_in">free</span>(q.front);<br>        q.front=p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function">status <span class="hljs-title">enqueue</span><span class="hljs-params">(linkqueue &amp;q,qelemtype e)</span></span>&#123;<span class="hljs-comment">//入队</span><br>    queneptr *p;<br>    p=(queueptr)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(qnode));<br>    p-&gt;date=e;<br>    p-&gt;next=<span class="hljs-literal">NULL</span>;<br>    q.rear-&gt;next=p;<br>    q.rear=p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function">ststus <span class="hljs-title">dequeue</span><span class="hljs-params">(linkqueue &amp;q,qelemtype e)</span></span>&#123;<span class="hljs-comment">//出队</span><br>    queneptr *p;<br>    <span class="hljs-keyword">if</span>(q.front == q.rear) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    p=q.front-&gt;next;<br>    e=p-&gt;date;<br>    q.front-&gt;next=p-&gt;next;<br>    <span class="hljs-keyword">if</span>(q.rear==p)q.rear=q.front;<br>    <span class="hljs-keyword">delete</span> p;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-串、数组和广义表"><a href="#4-串、数组和广义表" class="headerlink" title="4.串、数组和广义表"></a>4.串、数组和广义表</h1><h2 id="4-1-串的定义"><a href="#4-1-串的定义" class="headerlink" title="4.1 串的定义"></a>4.1 串的定义</h2><p>串：零个或多个任意字符组成的有限序列</p><p>字串：一个串中任意连续字符的<strong>子序列</strong></p><p>主串：包含字串的串</p><p>字符位置：字符在序列中的序号</p><p>字串位置：子串中第一个字符在主串中的位置</p><p>空格串：由一个或多个空格组成的串，与空串不同</p><p>串相等：当且仅当两个串长度和对应位置字符都相同</p><h2 id="4-3-串的类型定义、存储结构及其运算"><a href="#4-3-串的类型定义、存储结构及其运算" class="headerlink" title="4.3 串的类型定义、存储结构及其运算"></a>4.3 串的类型定义、存储结构及其运算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 255</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">char</span> ch[MAXLEN+<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> length;<br>&#125;SString;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index_BF</span><span class="hljs-params">(SString S,SString T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(S.ch[i]==T.ch[j])&#123;i++;j++;&#125;<br>        <span class="hljs-keyword">else</span> &#123;i=i-j+<span class="hljs-number">2</span>;j=<span class="hljs-number">1</span>;&#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j&gt;=T.length)<span class="hljs-keyword">return</span> i-T.length;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Get_Next</span><span class="hljs-params">(SString T,<span class="hljs-type">int</span> next[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;next[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=T.length)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span> || T.ch[i] == T.ch[j])<br>        &#123;<br>            i++,j++;<br>            next[i]=j;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j=next[j];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index_KMP</span><span class="hljs-params">(SString S,SString T,<span class="hljs-type">int</span> pos)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> next_1 [S.length+<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">Get_Next</span>(S,next_1);<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>,i=pos;<br>    <span class="hljs-keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(S.ch[i]==T.ch[j])&#123;i++;j++;&#125;<br>        <span class="hljs-keyword">else</span> &#123;j=next_1[j];&#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j&gt;=T.length)<span class="hljs-keyword">return</span> i-T.length;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StrAssign</span><span class="hljs-params">(SString &amp;T,<span class="hljs-type">char</span> *chars)</span><span class="hljs-comment">//赋值</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i,n;<span class="hljs-type">char</span> *c;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>,c=chars;*c;++i,++c);<br><span class="hljs-keyword">if</span>(!i)<br>&#123;<br>T.ch=<span class="hljs-literal">NULL</span>;<br>T.length=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span>(!(T.ch=(<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(i*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>))))<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(n=<span class="hljs-number">0</span>;n&lt;=i<span class="hljs-number">-1</span>;n++)<br>&#123;<br>T.ch[n]=chars[n];<br>T.length=i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">ClearString</span><span class="hljs-params">(SString &amp;S)</span><span class="hljs-comment">//清空</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(S.ch)<br>&#123;<br><span class="hljs-built_in">free</span>(S.ch);<br>S.ch=<span class="hljs-literal">NULL</span>;<br>&#125;<br>S.length=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> OK;<br>&#125;<br><br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SubString</span><span class="hljs-params">(SString &amp;Sub,SString S,<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> len)</span><span class="hljs-comment">//求子串 </span></span><br><span class="hljs-function"> </span>&#123;<br> <span class="hljs-type">int</span> n; <br> <span class="hljs-keyword">if</span>(pos&lt;<span class="hljs-number">0</span>||pos&gt;S.length||len&lt;<span class="hljs-number">0</span>||len&gt;S.length-pos+<span class="hljs-number">1</span>)<br> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br><br><span class="hljs-keyword">if</span>(!len)<br>&#123;<br>Sub.ch=<span class="hljs-literal">NULL</span>;<br>Sub.length=<span class="hljs-number">0</span>;<br> &#125; <br><span class="hljs-keyword">else</span><br>&#123;<br>Sub.ch=(<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(len * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;n&lt;=len<span class="hljs-number">-1</span>;n++)<br>&#123;<br>Sub.ch[n]=S.ch[pos+n<span class="hljs-number">-1</span>];<br>&#125;<br>Sub.length=len;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StrCompare</span><span class="hljs-params">(SString S,SString T)</span><span class="hljs-comment">//比较</span></span><br><span class="hljs-function"> </span>&#123;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;S.length&amp;&amp;i&lt;T.length;i++)<br> &#123;<br> <span class="hljs-keyword">if</span>(S.ch[i]!=T.ch[i])<br> <span class="hljs-keyword">return</span> S.ch[i]-T.ch[i];<br><span class="hljs-keyword">else</span><br>  <span class="hljs-keyword">return</span> S.length-T.length;<br> &#125;<br> &#125;<span class="hljs-comment">//若S&gt;T，则返回值&gt;0; 若S=T，则返回值0；若S&lt;T，则返回值&lt;0 </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StrLength</span><span class="hljs-params">(HString T)</span><span class="hljs-comment">//串长 </span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> T.length;<br> &#125; <br><br></code></pre></td></tr></table></figure><h2 id="4-4-数组的定义"><a href="#4-4-数组的定义" class="headerlink" title="4.4 数组的定义"></a>4.4 数组的定义</h2><h3 id="4-1-1-数组的抽象数据类型定义"><a href="#4-1-1-数组的抽象数据类型定义" class="headerlink" title="4.1.1 数组的抽象数据类型定义"></a>4.1.1 数组的抽象数据类型定义</h3><h2 id="4-5-广义表"><a href="#4-5-广义表" class="headerlink" title="4.5 广义表"></a>4.5 广义表</h2><p>广义表(又称链表lists)：是n个元素的有限序列，其中每一个元素或者是原子，或者是一个广义表</p><p>通常记作：LS&#x3D;（a<del>1</del>，a<del>2</del>，—，a<del>n</del>），其中：用大写字母表示广义表，小写字母表示原子</p><p>表头是非空广义表的第一个元素，表尾是除去表头元素，其他元素构成的表</p><p>例：</p><ol><li>A&#x3D;（） 空表</li><li>B&#x3D;（（））长度1，表头表尾均是（）</li><li>C&#x3D;（a，（b，c）） 长度2，由原子a和子表（b，c）组成</li><li>D&#x3D;（x，y，z）长度3 由三个原子组成，头：a，尾：（y，z）</li><li>E&#x3D;（C,D） 长度2 由两个子表组成，头：C，尾：D</li><li>F&#x3D;（a，F） 长度 2 第一项为原子，第二项是本身，F&#x3D;（a，（a，….））</li></ol><p>长度：最外层所包含的元素</p><p>深度：广义表展开后所含括号的重数</p><h1 id="5-树和二叉树"><a href="#5-树和二叉树" class="headerlink" title="5.树和二叉树"></a>5.树和二叉树</h1><h2 id="5-1-树的定义"><a href="#5-1-树的定义" class="headerlink" title="5.1 树的定义"></a>5.1 树的定义</h2><h3 id="5-1-2-树的基本用语"><a href="#5-1-2-树的基本用语" class="headerlink" title="5.1.2 树的基本用语"></a>5.1.2 树的基本用语</h3><p><strong>根结点</strong>：非空树中无前趋结点的结点</p><p>结点的<strong>度</strong>：结点拥有的子树数</p><p>树的<strong>度</strong>：树内各结点的度的最大值</p><p>树的<strong>深度</strong>：树中结点的最大层次</p><p>度 ≠ 0 分支结点（非终端结点） 度 &#x3D; 0 叶子（终端结点）</p><p>结点的子树的根称为该结点的<strong>孩子</strong>，该结点称为孩子的<strong>双亲</strong></p><p>拥有相同双亲的孩子（子树）称为<strong>兄弟</strong></p><p>双亲在同一层，但双亲不同 称为<strong>堂兄弟</strong></p><p>结点的<strong>祖先</strong>：从根到该结点所经分支上的所有结点</p><p>结点的<strong>子孙</strong>：以某节点为根的子树中的任一结点</p><p>有序树：树中结点的各子树从左至右有次序</p><p>森林：是m（m≥0）颗互不相交的树的集合；</p><h3 id="5-1-3-二叉树的定义"><a href="#5-1-3-二叉树的定义" class="headerlink" title="5.1.3 二叉树的定义"></a>5.1.3 二叉树的定义</h3><p>二叉树是n各结点的有限集，它或者是<strong>空集</strong>或者由一个根节点及两颗互不相交的分别称为这个根的<strong>左子树和右子树</strong>的二叉树组成</p><p>特点：</p><ul><li>每个结点最多由两个孩子</li><li>子树由左右之分，其次序不能颠倒</li><li>二叉树可以是空集合，根可以有空的左子树或者右子树</li><li>二叉树<strong>不是</strong>树的特殊情况，是两个概念</li></ul><h2 id="5-3-树和二叉树的抽象数据类型定义"><a href="#5-3-树和二叉树的抽象数据类型定义" class="headerlink" title="5.3 树和二叉树的抽象数据类型定义"></a>5.3 树和二叉树的抽象数据类型定义</h2><h2 id="5-4-二叉树的性质和存储结构"><a href="#5-4-二叉树的性质和存储结构" class="headerlink" title="5.4 二叉树的性质和存储结构"></a>5.4 二叉树的性质和存储结构</h2><ol><li>在二叉树的第i曾上至多有2^i-1^个结点  第i层至少有1个结点</li><li>深度为k的二叉树至多有2^k^-1个结点 第k层至少有k个结点</li><li>对任何一颗二叉树T，如果其叶子树为n<del>0</del>，度为2的节点数为n<del>2</del>，则n<del>0</del>&#x3D;n<del>2</del>+1</li></ol><p>两种特殊形式的二叉树：满二叉树和完全二叉树</p><ul><li>满二叉树：一棵深度为k且有2^k^-1个结点的二叉树<ol><li>每一层上的结点数都是最大结点数</li><li>叶子结点全部在最底层</li><li>在同样深度的二叉树中结点个数最多，叶子结点个数最多</li></ol></li><li>完全二叉树：深度为k的具有n个结点的二叉树，当且仅当每一个结点都与深度为k的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树<ol><li>在满二叉树中，从最后一个结点开始，<strong>连续去掉任意</strong>个结点，就是一棵完全二叉树</li><li>叶子只可能分布在层次最大的两层上</li><li>对任一结点，如果其右子树的最大层次为i，则其左子树的最大层次必为i或i+1；</li><li>具有n个结点完全二叉树的深度为[log<del>2</del>n]+1</li></ol></li></ul><p>存储结构：</p><ul><li><p>顺序存储：按满二叉树的结点层次编号，依次存放二叉树中的数据元素</p><ul><li>缺点：如右单支数，在最坏的情况下，深度为k的且只有k个节点的单支树需要长度为2^k^-1的一维数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXTSIZE 100</span><br>Typedef TElemType SqBiTree[MAXTSIZE];<br>SqBiTree bt;<br></code></pre></td></tr></table></figure></li><li><p>链式存储结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiNode</span>&#123;<span class="hljs-comment">//二叉链表</span><br>    TElemType date;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiNode</span> *lchild,*rchild;<br>&#125;BiNode,*BiTree;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TriNode</span>&#123;<span class="hljs-comment">//三叉链表</span><br>    TElemType date;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TriNode</span> *lchild,*rchild,*parent;<br>&#125;TriNode,*TriTree;<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-5-遍历二叉树和线索二叉树"><a href="#5-5-遍历二叉树和线索二叉树" class="headerlink" title="5.5 遍历二叉树和线索二叉树"></a>5.5 遍历二叉树和线索二叉树</h2><h3 id="5-5-1-遍历二叉树"><a href="#5-5-1-遍历二叉树" class="headerlink" title="5.5.1 遍历二叉树"></a>5.5.1 遍历二叉树</h3><p>遍历定义：顺着某一条搜索路径巡防二叉树中的结点，使得每个结点均被访问依次，而且仅被访问一次</p><p>遍历二叉树算法描述：DLR(先序遍历) LDR(中序遍历) LRD(后序遍历)</p><ul><li><p>先序遍历二叉树的操作定义：</p><ol><li>先访问根结点</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ol></li><li><p>中序遍历二叉树的操作定义</p><ol><li>中序遍历左子树</li><li>访问根结点</li><li>中序遍历右子树</li></ol></li><li><p>后续遍历二叉树的操作定义</p><ol><li><p>后序遍历左子树</p></li><li><p>后序遍历右子树</p></li><li><p>访问根结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span><span class="hljs-comment">//前序</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">visit</span>(T);<span class="hljs-comment">//自行定义具体代码              D</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;lchild);<span class="hljs-comment">//        L</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;rchild);<span class="hljs-comment">//        R</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span><span class="hljs-comment">//中序</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;lchild);<span class="hljs-comment">//        L</span><br>        <span class="hljs-built_in">visit</span>(T);<span class="hljs-comment">//自行定义具体代码              D</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;rchild);<span class="hljs-comment">//        R</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">PostOrderTraverse</span><span class="hljs-params">(BiTree T)</span><span class="hljs-comment">//后序</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> OK;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;lchild);<span class="hljs-comment">//        L</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;rchild);<span class="hljs-comment">//        R</span><br>        <span class="hljs-built_in">visit</span>(T);<span class="hljs-comment">//自行定义具体代码              D</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">InOrderTraverse_1</span><span class="hljs-params">(BiTree T)</span><span class="hljs-comment">//中序遍历的非递归算法 利用栈</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree p;<br>    <span class="hljs-built_in">Initstack</span>(S);<br>    p=T;<br>    <span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">StackEmpty</span>(S))&#123;<br>        <span class="hljs-keyword">if</span>(p)&#123;<br>            <span class="hljs-built_in">push</span>(S,p);<br>            p=p-&gt;lchild;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">pop</span>(S,q);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,q-&gt;date);<br>            p=q-&gt;rchild;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>二叉树的层次遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BiNode *b)</span></span>&#123;<span class="hljs-comment">//二叉树的层次遍历，利用队列</span><br>    BiNode *p;<br>    SqQueue *qu;<br>    <span class="hljs-built_in">InitQueue</span>(qu);<br>    <span class="hljs-built_in">enQueue</span>(qu,b);<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">QueueEmpty</span>(qu))&#123;<br>        <span class="hljs-built_in">deQueue</span>(qu,p);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,p-&gt;date);<br>        <span class="hljs-keyword">if</span>(p-&gt;lchild!=<span class="hljs-literal">NULL</span>)<span class="hljs-built_in">enQueue</span>(qu,p-&gt;lchild);<br>        <span class="hljs-keyword">if</span>(p-&gt;rchild!=<span class="hljs-literal">NULL</span>)<span class="hljs-built_in">enQueue</span>(qu,p-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二叉树的建立：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">CreatBitree</span><span class="hljs-params">(BiTree &amp;T)</span></span>&#123;<span class="hljs-comment">//创建二叉树</span><br>    <span class="hljs-type">char</span> ch;<br>    cin&gt;&gt;ch;<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&quot;#&quot;</span>)T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(!(T=(BiNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiNode))))<br>            <span class="hljs-built_in">exit</span>(OVERFLOW);<br>        T-&gt;date = ch;<br>        <span class="hljs-built_in">CreatBitree</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">CreatBitree</span>(T-&gt;rchild);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>树的复制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">copy</span><span class="hljs-params">(BiTree T,BiTree &amp;NewT)</span></span>&#123;<span class="hljs-comment">//树的复制</span><br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)&#123;<br>        NewT=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        NewT=<span class="hljs-keyword">new</span> BiNode;<br>        NewT-&gt;date=T-&gt;date;<br>        <span class="hljs-built_in">copy</span>(T-&gt;lchild,NewT-&gt;lchild);<br>        <span class="hljs-built_in">copy</span>(T-&gt;rchild,NewT-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>计算深度:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Depth</span><span class="hljs-params">(BiTree T)</span></span>&#123;<span class="hljs-comment">//计算深度</span><br>    <span class="hljs-type">int</span> m,n;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        m=<span class="hljs-built_in">Depth</span>(T-&gt;lchild);<br>        n=<span class="hljs-built_in">Depth</span>(T-&gt;rchild);<br>        <span class="hljs-keyword">if</span>(m&gt;n) <span class="hljs-keyword">return</span> (m+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span>(n+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>计算结点:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NodeCount</span><span class="hljs-params">(BiTree T)</span></span>&#123;<span class="hljs-comment">//计算结点</span><br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">NodeCount</span>(T-&gt;lchild)+<span class="hljs-built_in">NodeCount</span>(T-&gt;rchild)+<span class="hljs-number">1</span>;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>计算叶子结点数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LeafCound</span><span class="hljs-params">(BiTree T)</span></span>&#123;<span class="hljs-comment">//计算叶子结点数</span><br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(T-&gt;lchild == <span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild ==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">LeafCound</span>(T-&gt;lchild)+<span class="hljs-built_in">LeafCound</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-5-2-线索二叉树"><a href="#5-5-2-线索二叉树" class="headerlink" title="5.5.2 线索二叉树"></a>5.5.2 线索二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  FALSE   0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  OK  1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  ERROR   0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INFEASIBLE   -1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW   -2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXTSIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> TElemType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiThrNode</span>&#123;<span class="hljs-comment">//线索二叉树链表</span><br>    TElemType date;<br>    <span class="hljs-type">int</span> ltag,rtag;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiNode</span> *lchild,*rchild;<br>&#125;BiThrNode,*BiThrTree;<br><br></code></pre></td></tr></table></figure><h2 id="5-6-树和森林"><a href="#5-6-树和森林" class="headerlink" title="5.6 树和森林"></a>5.6 树和森林</h2><ol><li><p>双亲表示法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTNode</span>&#123;<br>    TElemType date;<br>    <span class="hljs-type">int</span> parent;<br>&#125;PTNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    PTNode nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> r,n;<br>&#125;PTree;<br></code></pre></td></tr></table></figure></li><li><p>孩子链表（也可和双亲结合）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span>&#123;<span class="hljs-comment">//孩子结点结构</span><br>    <span class="hljs-type">int</span> child;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span> *next;<br>&#125;*ChildPtr;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<span class="hljs-comment">//双亲结点结构</span><br>    TElemType date;<br>    ChildPtr fistchild;<br>&#125;CTBox;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    CTBox nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> n,r;<br>&#125;CTree;<br><br></code></pre></td></tr></table></figure></li><li><p>孩子兄弟表示法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span>&#123;<br>    TElemType date;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span> *firstchild,*nextsibling;<span class="hljs-comment">//指向第一个孩子结点和下一个兄弟结点</span><br>&#125;CSNode,*CSTree;<br><br></code></pre></td></tr></table></figure></li></ol><p>树的遍历只有先根遍历与后根遍历</p><p>森林的遍历：</p><ul><li><p>先序遍历：</p><ol><li><p>访问森林中第一棵树的根结点</p></li><li><p>先序遍历森林中第一棵树的子树森林</p></li><li><p>先序遍历森林中（除第一棵树之外）其余树构成的森林</p><p>即从左至右对森林中每一棵树进行先序遍历</p></li></ol></li><li><p>中序遍历</p><ol><li><p>中序遍历森林中第一棵树的字数森林</p></li><li><p>访问森林中第一棵树的根结点</p></li><li><p>中序遍历森林中（除第一棵树之外）其余树构成的森林</p><p>即从左至右对森林中的每一棵树进行后根遍历</p></li></ol></li></ul><h2 id="5-7-哈夫曼树及其应用"><a href="#5-7-哈夫曼树及其应用" class="headerlink" title="5.7 哈夫曼树及其应用"></a>5.7 哈夫曼树及其应用</h2><h3 id="5-7-1-哈夫曼树基本概念"><a href="#5-7-1-哈夫曼树基本概念" class="headerlink" title="5.7.1 哈夫曼树基本概念"></a>5.7.1 哈夫曼树基本概念</h3><p>哈夫曼树即最优树（带权路径长度最短的树）</p><p>哈夫曼树：最优二叉树</p><h3 id="5-7-2-哈夫曼树的构造算法"><a href="#5-7-2-哈夫曼树的构造算法" class="headerlink" title="5.7.2 哈夫曼树的构造算法"></a>5.7.2 哈夫曼树的构造算法</h3><p><img src="C:\Users\23256\AppData\Roaming\Typora\typora-user-images\image-20220126194417617.png" alt="image-20220126194417617"></p><p>哈夫曼树具体代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<span class="hljs-comment">//结点定义</span><br>    <span class="hljs-type">int</span> parent,lch,rch;<br>    <span class="hljs-type">int</span> weight;<br>&#125;HTNode,*HuffmanTree;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> **HuffmanCode;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Select</span><span class="hljs-params">(HuffmanTree HT,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> &amp;s1,<span class="hljs-type">int</span> &amp;s2)</span></span>&#123;<span class="hljs-comment">//x</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> min1=<span class="hljs-number">1000</span>; <br>    <span class="hljs-type">int</span> min2=<span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-keyword">if</span>(HT[i].parent==<span class="hljs-number">0</span> &amp;&amp; min1&gt;HT[i].weight)&#123;<br>            min1=HT[i].weight;<br>            s1=i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i!=(s1)&amp;&amp;HT[i].parent==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">if</span>(HT[i].weight&lt;min2)&#123;<br>            min2=HT[i].weight;<br>            s2=i;<br>        &#125;<br>  <br>    &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreatHuffmanTree</span><span class="hljs-params">(HuffmanTree HT,<span class="hljs-type">int</span> n)</span></span>&#123;<span class="hljs-comment">//创建一个哈夫曼树</span><br>    <span class="hljs-type">int</span> s1=<span class="hljs-number">0</span>,s2=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> m=<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;<br>    HT=<span class="hljs-keyword">new</span> HTNode[m+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<span class="hljs-comment">//初始化，全部置0</span><br>        HT[i].lch=<span class="hljs-number">0</span>;<br>        HT[i].rch=<span class="hljs-number">0</span>;<br>        HT[i].parent=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;HT[i].weight;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n+<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-built_in">Select</span>(HT,i<span class="hljs-number">-1</span>,s1,s2);<br>        HT[s1].parent=i;<br>        HT[s2].parent=i;<br>        HT[i].lch=s1;<br>        HT[i].rch=s2;<br>        HT[i].weight=HT[s1].weight+HT[s2].weight;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//哈夫曼编码实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreatHuffmanCode</span><span class="hljs-params">(HuffmanTree HT,HuffmanCode &amp;HC,<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">int</span> start;<br>    <span class="hljs-type">int</span> c,f;<br>    HC=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span> *[n+<span class="hljs-number">1</span>];<br>    <span class="hljs-type">char</span>* cd=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span> [n];<br>    cd[n<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        start=n<span class="hljs-number">-1</span>;<br>        c=i;<br>        f=HT[i].parent;<br>        <span class="hljs-keyword">while</span>(f!=<span class="hljs-number">0</span>)&#123;<br>            start--;<br>            <span class="hljs-keyword">if</span>(HT[f].lch==c)cd[start]=<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">else</span> cd[start]=<span class="hljs-string">&#x27;1&#x27;</span>;<br>            c=f;<br>            f=HT[f].parent;<br>        &#125;<br>        HC[i]=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span> [n-start];<br>        <span class="hljs-built_in">strcpy</span>(HC[i],&amp;cd[start]);<br>    &#125;<br>    <span class="hljs-keyword">delete</span> cd;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
